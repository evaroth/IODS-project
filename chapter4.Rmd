#RStudio Exercise 4 - Clustering and classification

```{r MASS}
library(MASS)
data("Boston")
```

###4.1Exploring the dataset "Boston"
There are many data sets already loaded in R or included in the package installations. In this exercise we will practise our analysis on a data set called "Boston" from the "MASS" package. 
The data set concernes the housing values in the suburbs of Boston. It has 14 varibales with 506 observations, concerning living standards, like accssability and number of rooms.   
The description of the variables are:  
crim    -per capita crime rate by town.  
zn      -proportion of residential land zoned for lot over 25,000sq.ft.  
indus   -proportion of non-retail business acres per town.  
chas    -Charles River dummy variable (=1 if tract bounds river; 0 otherwise).  
nox     -nitrogen oxides concentration (parts per 10 million).  
rm      -average number of rooms per dwelling.  
age     -proportion of owner-occupied units built prior to 1940.  
dis     -weigthed mean of distances to five Boston employment centres.  
rad     -index of accessibility to radial highways.  
tax     -full-valua property-tax rate per \10,000$.  
ptratio -pupil-teacher ratio by town.  
black   -1000(Bk-0.63)^2 where Bk is the proportion of blacks by town.  
lstat   -lower status of the population (percent).  
medv    -median value of owner-occupied homes in \$1000s.  

```{r dim Boston}
dim(Boston)
str(Boston)
```  
All the observations of the variables are numerival except for indus and rad, which are integer.

Now, lets have a look at the summary of the distributions of the variables. Here we cann see for example, that the mean crime rate is 3.61, whereas the median is 0.25 and the values range between 0.00 and 88.9. The mean of the pupil/teacher ratio is 18.46, which I find surprisingly low.
```{r summary.variables}
summary(Boston)
```  
With the following barplots we can get a graphical overview of the distribution of the data withing the variables.
```{r bar}
library(ggplot2)
library(tidyr)
gather(Boston) %>% ggplot(aes(value)) + facet_wrap("key", scales = "free") + geom_bar()
```

Using the pairs function we can see how the variables are distributed and derive first assumptions about their relationships to each other. However, there are too many variables to get an overview with one glance.
```{r pairs.boston}
pairs(Boston)
```  
```{r boston.atrix}

library(corrplot)

cor_matrix<-cor(Boston)
cor_matrix %>% round(digits=2)
corrplot(cor_matrix, method="circle", type = "upper", cl.pos = "b", tl.pos = "d", tl.cex = 0.6)
```  

A better option to investigate the relationship of the variables is the corrolationplot. The colour indicates what kind of correlation we have:    
red - negative correlation  
blue - positive correlation  
The size of the cirlce and the intensity of the colour indicate the correlation coefficient.  
strong colours - corrolation coefficient is high    
light colours  - corrolation coefficient is low  
The strongest correlation can be found betwenn the index of accessibility to radial highways and the full-valua property-tax rate per \10,000$. The weighted mean of distances to five Boston employment centres correlates strongly with age, nitrogen oxide concentration and the proportion of non-retail business acres per town. 



###4.2 Data wrangling 
Standardizing the dataset and creating a factor variable for the crime rate. As the data contains only numerical values, we can use the scale() function to standardize the whole dataset. Furthermore we are dividing the dataset into a train and a test set with 80% and respectively 20% of the observations per variable, which are randomly selected.

```{r boston.scaled}
boston_scaled <- scale(Boston)
summary(boston_scaled)
```
 The variable crim describes the per capita crime rate by town.
```{r variable}
class(boston_scaled)
boston_scaled <- as.data.frame(boston_scaled)
bins <- quantile(boston_scaled$crim)
crime <- cut(boston_scaled$crim, breaks = bins, include.lowest = TRUE, labels = c("low", "med_low", "med_high", "high"))
boston_scaled <- dplyr::select(boston_scaled, -crim)
boston_scaled <- data.frame(boston_scaled, crime)
head(boston_scaled)
```

```{r split}
n <- nrow(boston_scaled)
ind <- sample(n, size = n*0.8)
train <- boston_scaled[ind,]
test <- boston_scaled[-ind,]
dim(test)
dim(train)
```

Fitting a linear discriminant analysis to the training set. Crime is a target varaible and all the other variables are predictors.

```{r discr.analysis}
lda.fit <- lda(crime ~ ., data = train)
lda.fit
lda.arrows <- function(x, myscale = 1, arrow_heads = 0.1, color = "orange", tex = 0.75, choices = c(1,2)){
  heads <- coef(x)
  arrows(x0 = 0, y0 = 0, 
         x1 = myscale * heads[,choices[1]], 
         y1 = myscale * heads[,choices[2]], col=color, length = arrow_heads)
  text(myscale * heads[,choices], labels = row.names(heads), 
       cex = tex, col=color, pos=3)
}
classes <- as.numeric(train$crime)
plot(lda.fit, dimen = 2, col = classes, pch = classes)
lda.arrows(lda.fit, myscale = 1)

```

####Predict LDA
```{r predict.crime}
correct_classes<-test$crime
test<-dplyr::select(test, -crime)
lda.pred <- predict(lda.fit, newdata = test)
table(correct = correct_classes, predicted = lda.pred$class)
```

#### K-means Clustering

```{r reload}
#reloading
data(Boston)

#scale dataset and make data frame
boston_scaled1<-as.data.frame(scale(Boston))
```

For calculating the distances between the obeservations we use the most common, euclidean distance.

```{r distances}
dist_eu <-dist(boston_scaled1)
summary(dist_eu)
```

Now we apply K-means to the dataset. We start with a number of 4 cluster centers.
```{r Kmeans}
km <- kmeans(boston_scaled1, centers = 4)
```
However, we want to determine the optimal number of clusters.
```{r number of clusters}
set.seed(123)

#set the max number of clusters to be ten
k_max<- 10

#calculate total WCSS
twcss <- sapply(1:k_max, function(k){kmeans(Boston, k)$tot.withinss})

#visualizing WCSS
qplot(x = 1:k_max, y = twcss, geom = 'line')
```

```{r run Kmeans again}
km <- kmeans(boston_scaled1, centers = 2)

#visualize Kmeans
pairs(boston_scaled1, col = km$cluster)
pairs(boston_scaled1[6:10], col = km$cluster)
```


####Bonus
At first we scale the Boston dataset again.
```{r Bonus}
summary(Boston)
boston_scaled2 <-scale(Boston)
summary(boston_scaled2)
```
Now we perform the K-means on the standardized dataset.

```{r kmeansbonus}
km2 <- kmeans(boston_scaled2, center = 3)
boston_scaled2 <- as.data.frame(boston_scaled2)
```

Finally we perform Linear Discriminant Analysis, using the clusters as target classes, including all the variables from the Boston data in the LDA model.
```{r lda}
lda.fit2 <- lda(km2$cluster~., data = boston_scaled2)
```
Visualizing the results, we can observe...

```{r ldavisual}
# function for the lda biplot arrows
lda.arrows <- function(x, myscale = 1, arrow_heads = 0.1, color = "red", tex = 0.75, choices = c(1,2)){
  heads <- coef(x)
  arrows(x0 = 0, y0 = 0, 
         x1 = myscale * heads[,choices[1]], 
         y1 = myscale * heads[,choices[2]], col=color, length = arrow_heads)
  text(myscale * heads[,choices], labels = row.names(heads), 
       cex = tex, col=color, pos=3)
}

# setting target classes as numeric
classes <- as.numeric(km2$cluster)

# plotting the lda results
plot(lda.fit2, dimen = 2, col=classes, pch= classes)
lda.arrows(lda.fit, myscale = 1)
```

####Super bonus
We are running the code bellow for the scaled train data that we used to fit the LDA.It creates a matrix product, which is a projection of the data points.

```{r super bonus}
model_predictors <- dplyr::select(train, -crime)

# check the dimensions
dim(model_predictors)
dim(lda.fit$scaling)

# matrix multiplication
matrix_product <- as.matrix(model_predictors) %*% lda.fit$scaling
matrix_product <- as.data.frame(matrix_product)
```
Now we are installing and accessing the plotly package in order to create a 3D plot from our data.
```{r 3Dplot}
library(plotly)
plot_ly(x = matrix_product$LD1, y = matrix_product$LD2, z = matrix_product$LD3, type= 'scatter3d', mode='markers')
```

We draw the same plot again, but set the crime classes to be the colours.
```{r 3Dcrime}
plot_ly(x = matrix_product$LD1, y = matrix_product$LD2, z = matrix_product$LD3, type= 'scatter3d', mode='markers', color = train$crime)
```

Drawing the same plot again with the colours matching the clusters of the K-means.
```{r 3D cluster}
plot_ly(x = matrix_product$LD1, y = matrix_product$LD2, z = matrix_product$LD3, type= 'scatter3d', mode='markers', color = train$cl)
```
















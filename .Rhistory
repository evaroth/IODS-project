str(por)
head(por)
# joining the two data sets
# step no 1, accessing dplyr library
library(dplyr)
# columns used as identifiers
join_by <- c("school","sex","age","address","famsize","Pstatus","Medu","Fedu","Mjob","Fjob","reason","nursery","internet")
# joining the two data sets by the identifiers
math_por <- inner_join(math, por, by = join_by, suffix = c(".math", ".por"))
dim(math_por)
str(math_por)
# creating a new data frame with only the joined columns
alc <- select(math_por, one_of(join_by))
# columns that were not used for joining the data
notjoined_columns <- colnames(math)[!colnames(math) %in% join_by]
for(column_name in notjoined_columns) {
two_columns <- select(math_por, starts_with(column_name))
first_column <- select(two_columns, 1)[[1]]
if(is.numeric(first_column)) {
alc[column_name] <- round(rowMeans(two_columns))
} else {
alc[column_name] <- first_column
}
}
glimpse(alc)
# creating a new column alc-use to the joined data, containing the average of the answers related to weekday and weekend alcohol consumtion
# accessing the tidyverse packages dplyr and ggplot2
library(dplyr)
library(ggplot2)
# defining a new column alc_use by combining weekday and weekend alcohol use
alc <- mutate(alc, alc_use = (Dalc + Walc) / 2)
# define a new logical column 'high_use'
alc <- mutate(alc, high_use = alc_use > 2)
glimpse(alc)
# Chapter 3
alcdata <-read.csv("/Users/eva-mariaroth/Documents/GitHub/IODS-project/alcjoint", header=TRUE, sep=";")
glimpse(alcdata)
# Chapter 3
alcdata <-read.csv("/Users/eva-mariaroth/Documents/GitHub/IODS-project/alcjoint", header=TRUE, sep=",")
glimpse(alcdata)
``` {r readdata}
alcdata <-read.csv("/Users/eva-mariaroth/Documents/GitHub/IODS-project/alcjoint", header=TRUE, sep=";")
# Chapter 3
alcdata <-read.csv("/Users/eva-mariaroth/Documents/GitHub/IODS-project/alcjoint", header=TRUE, sep=",")
glimpse(alcdata)
glimpse(alcdata)
alcdata <-read.csv("/Users/eva-mariaroth/Documents/GitHub/IODS-project/alcjoint", header=TRUE, sep=",")
glimpse(alcdata)
colnames(alcdata)
dim(alcdata)
exp(alcdata)
str(alcdata)
dim(alcdata)
colnames(alcdata)
dim(alcdata)
dim(alcdata)
colnames(alcdata)
alc <-read.csv("/Users/eva-mariaroth/Documents/GitHub/IODS-project/alcjoint", header=TRUE, sep=",")
dim(alc)
colnames(alc)
m<-glm(high_use ~ famrel + absences + failures + G3, data = alc, family = "binomal")
m<-glm(high_use ~ famrel + absences + failures + G3, data = alc, family = "binomial")
summary(m)
selected_variables <- subset(alc, select = c("famrel", "absences, "failures", "G3", "alc_use")
selected_variables <- subset(alc, select = c("famrel", "absences", "failures", "G3", "alc_use")
selected_variables <- subset(alc, select = c("famrel", "absences", "failures", "G3", "alc_use"))
library(tidyr)
library(ggplot2)
install.packages("tidyr")
install.packages("dplyr")
library("tidyr")
library(tidyr)
library(ggplot2)
gather(selected_variables) %>% ggplot(aes(value)) + facet_wrap("key", scales = "free") + geom_bar()
selected_variables <- subset (alc, select = c("famrel", "absences", "failures", "G3"))
selected_variables <- subset (alc, select = c("famrel", "absences", "failures", "G3", "alc_use"))
library(tidyr)
library(ggplot2)
gather(selected_variables) %>% ggplot(aes(value)) + facet_wrap("key", scales = "free") + geom_bar()
selected_variables <- subset (alc, select = c("famrel", "absences", "failures", "G3", "alc_use"))
library(tidyr)
library(ggplot2)
gather(selected_variables) %>% ggplot(aes(value)) + facet_wrap("key", scales = "free") + geom_bar()
g1 <- ggplot(alc, aes(x = high_use))
g1 + geom_bar() + facet_wrap("failure")
g1 <- ggplot(alc, aes(x = alc_use))
g1 + geom_bar() + facet_wrap("failure")
g1 <- ggplot(alc, aes(x = high_use))
g1 + geom_bar() + facet_wrap("failures")
g1 <- ggplot(alc, aes(x = failures))
g1 + geom_bar() + facet_wrap("high_use")
g1 <- ggplot(alc, aes(high_use, y = failures, col =sex))
g1 + geom_boxplot() + ylab("Grades") + ggtitle("letssee")
g1 + geom_boxplot() + ylab("failures") + ggtitle("letssee")
g1 + geom_boxplot() + ylab("Grades") + ggtitle("letssee")
g1 <- ggplot(alc, aes(high_use, y = G3, col =sex))
g1 + geom_boxplot() + ylab("Grades") + ggtitle("letssee")
g1 + geom_boxplot() + ylab("Grades") + ggtitle("effects on high alcohol consumption on grades")
g1 + geom_boxplot() + ylab("Grades") + ggtitle("Effects on high alcohol consumption on grades")
g1 <- ggplot(alc, aes(high_use, y = failures, col =sex))
g1 + geom_boxplot() + ylab("failures") + ggtitle("Effects on high alcohol consumption on grades")
g1 <- ggplot(alc, aes(high_use, y = failures, col =sex))
g1 + geom_boxplot() + ylab("failures") + ggtitle("Effects on high alcohol consumption on amount of failed courses")
g1 <- ggplot(alc, aes(high_use, y = failures, col =sex))
g1 + geom_boxplot() + ylab("famrel") + ggtitle("Relation between family situation and high alcohol consumtion")
m<-glm(high_use ~ famrel + absences + failures + G3, data = alc, family = "binomial")
summary(m)
alc %>% group_by (high_use) %>% summarise (count = n(), mean_grade = mean (G3))
library(tidyr)
library(ggplot2)
gather(selected_variables) %>% ggplot(aes(value)) + facet_wrap("key", scales = "free") + geom_bar()
alc %>% group_by (high_use) %>% summarise (count = n(), mean_grade = mean (G3))
library(dplyr)
alc %>% group_by (high_use) %>% summarise (count = n(), mean_grade = mean (G3))
alc %>% group_by (high_use) %>% summarise (count = n(), mean_grade = mean (famrel))
alc %>% group_by (high_use) %>% summarise (count = n(), mean_grade = mean (famrel))
alc %>% group_by (high_use) %>% summarise (count = n(), mean_grade = mean (absences))
alc %>% group_by (high_use) %>% summarise (count = n(), mean_grade = mean (failures))
help(summary.glm)
example(glm)
alc <-read.csv("/Users/eva-mariaroth/Documents/GitHub/IODS-project/alcjoint", header=TRUE, sep=",")
colnames(alc)
selected_variables <- subset (alc, select = c("famrel", "absences", "failures", "G3", "alc_use"))
library(tidyr)
library(ggplot2)
gather(selected_variables) %>% ggplot(aes(value)) + facet_wrap("key", scales = "free") + geom_bar()
g1 <- ggplot(alc, aes(high_use, y = G3, col =sex))
g1 + geom_boxplot() + ylab("Grades") + ggtitle("Effects on high alcohol consumption on grades")
alc %>% group_by (high_use) %>% summarise (count = n(), mean_grade = mean (G3))
library(dplyr)
alc %>% group_by (high_use) %>% summarise (count = n(), mean_grade = mean (G3))
alc %>% group_by (high_use) %>% summarise (count = n(), mean_grade = mean (famrel))
alc %>% group_by (high_use) %>% summarise (count = n(), mean_grade = mean (absences))
alc %>% group_by (high_use) %>% summarise (count = n(), mean_grade = mean (failures))
m<-glm(high_use ~ famrel + absences + failures + G3, data = alc, family = "binomial")
summary(m)
OR <- coef(m) %>% exp()
CI <- confint(m) %>% exp()
OR <- coef(m) %>% exp()
m<-glm(high_use ~ famrel + absences + failures + G3, data = alc, family = "binomial")
OR <- coef(m) %>% exp()
summary(m)
OR <- coef(m) %>% exp()
CI <- confint(m) %>% exp()
coef(m)
m <- glm(high_use ~ failures + absences, data = alc, family = "binomial")
probabilities <- predict(m, type = "response")
alc <- mutate(alc, probability = probabilities)
head(alc, n=10)
alc <- mutate(alc, prediction = probability > 0.5)
head(alc, n=10)
table(high_use = alc$high_use, prediction = alc$prediction)
OR <- coef(m) %>% exp()
CI <- confint(m) %>% exp()
g <- ggplot(alc, aes(x = probability, y = high_use, col = prediction))
g + geom_point()
loss_func <- function(class, prob) {
n_wrong <- abs(class - prob) > 0.5
mean(n_wrong)
}
loss_func <- function(class, prob) {
n_wrong <- abs(class - prob) > 0.5
mean(n_wrong)
}
loss_func(class = alc$high_use, prob = alc$probability)
install(Mass)
install.packages("Mass")
install.packages("MASS")
library(MASS)
data("Boston")
head(Boston)
dim(Boston)
head(Boston)
dim(Boston)
str(Boston)
```{r MASS}
install.packages("MASS")
install.packages("MASS")
library(MASS)
data("Boston")
head(Boston)
dim(Boston)
str(Boston)
language: R
cran: http://cran.rstudio.com
head(Boston)
dim(Boston)
str(Boston)
summary(Boston)
pairs(Boston)
cor_matrix<-cor(Boston)
cor_matrix %>% round(digits=2)
library(MASS)
data("Boston")
head(Boston)
dim(Boston)
str(Boston)
summary(Boston)
pairs(Boston)
library(tidyr)
cor_matrix<-cor(Boston)
cor_matrix %>% round(digits=2)
corrplot(cor_matrix, method="circle", type = "upper", cl.pos = "b", tl.pos = "d", tl.cex = 0.6)
library(dplyr)
library(ggplot2)
cor_matrix<-cor(Boston)
cor_matrix %>% round(digits=2)
corrplot(cor_matrix, method="circle", type = "upper", cl.pos = "b", tl.pos = "d", tl.cex = 0.6)
install.packages("MASS")
install.packages("MASS")
library(MASS)
data("Boston")
head(Boston)
dim(Boston)
str(Boston)
summary(Boston)
pairs(Boston)
library(tidyr)
library(dplyr)
library(ggplot2)
install.packages.(corrplot)
install.packages(corrplot)
cor_matrix<-cor(Boston)
cor_matrix %>% round(digits=2)
corrplot(cor_matrix, method="circle", type = "upper", cl.pos = "b", tl.pos = "d", tl.cex = 0.6)
install.packages(corrplot)
install.packages("corrplot"")
install.packages("corrplot")
install.packages("corrplot")
library(corrplot)
cor_matrix<-cor(Boston)
cor_matrix %>% round(digits=2)
corrplot(cor_matrix, method="circle", type = "upper", cl.pos = "b", tl.pos = "d", tl.cex = 0.6)
library(tidyr)
library(corrplot)
cor_matrix<-cor(Boston)
cor_matrix %>% round(digits=2)
corrplot(cor_matrix, method="circle", type = "upper", cl.pos = "b", tl.pos = "d", tl.cex = 0.6)
corrplot(cor_matrix, method="circle", type = "upper", cl.pos = "b", tl.pos = "d", tl.cex = 0.6, p.mat = res1$p, insig = "p-value", sig.level = -1)
corrplot(cor_matrix, method="circle", type = "upper", cl.pos = "b", tl.pos = "d", tl.cex = 0.6)
boston_scaled <- scale(Boston)
summary(boston_scaled)
class(boston_scaled)
boston_scaled <- as.data.frame(boston_scaled)
library(MASS)
class(boston_scaled)
boston_scaled <- as.data.frame(boston_scaled)
bins <- quantile(boston_scaled$crim)
bins
crime <- cut(boston_scaled$crim, breaks = bins, include.lowest = TRUE, labels = c("low", "med_low", "med_high", "high"))
table(crime)
boston_scaled <- dplyr::select(boston_scaled, -crim)
boston_scaled <- data.frame(boston_scaled, crime)
head(boston_scaled)
install.packages("MASS", repos="http://cran.us.r-project.org")
install.packages("MASS", repos = "http://cran.us.r-project.org")
library(MASS)
data("Boston")
install.packages("MASS")
install.packages("MASS")
library(MASS)
data("Boston")
install.packages("corrplot")
n <- nrow(boston_scaled)
n
ind <- sample(n, size = n*0.8)
train <- boston_scaled[ind,]
test <- boston_scaled[-ind,]
str(test)
str(test)
str(train)
dim(test)
dim(train)
train <- boston_scaled[ind,]
test <- boston_scaled[-ind,]
correct_classes <- test$crime
test <- dplyr::select(test, -crime)
dim(test)
dim(train)
lda.fit <- lda(crime ~ ., data = train)
lda.fit
lda.arrows <- function(x, myscale = 1, arrow_heads = 0.1, color = "orange", tex = 0.75, choices = c(1,2)){
heads <- coef(x)
arrows(x0 = 0, y0 = 0,
x1 = myscale * heads[,choices[1]],
y1 = myscale * heads[,choices[2]], col=color, length = arrow_heads)
text(myscale * heads[,choices], labels = row.names(heads),
cex = tex, col=color, pos=3)
}
classes <- as.numeric(train$crime)
lda.arrows(lda.fit, myscale = 1)
plot(lda.fit, dimen = 2, col = classes, pch = classes)
lda.arrows(lda.fit, myscale = 1)
lda.fit
plot(lda.fit, dimen = 2, col = classes, pch = classes)
lda.arrows(lda.fit, myscale = 1)
table(correct = correct_classes, predicted = lda.pred$class)
lda.pred <- predict(lda.fit, newdata = test)
table(correct = correct_classes, predicted = lda.pred$class)
gather(Boston) %>% ggplot(aes(value)) + facet_wrap("key", scales = "free") + geom_bar()
library(MASS)
data("Boston")
head(Boston)
dim(Boston)
str(Boston)
summary(Boston)
pairs(Boston)
library(tidyr)
library(corrplot)
cor_matrix<-cor(Boston)
cor_matrix %>% round(digits=2)
corrplot(cor_matrix, method="circle", type = "upper", cl.pos = "b", tl.pos = "d", tl.cex = 0.6)
gather(Boston) %>% ggplot(aes(value)) + facet_wrap("key", scales = "free") + geom_bar()
library(ggplot)
library(ggplot2)
gather(Boston) %>% ggplot(aes(value)) + facet_wrap("key", scales = "free") + geom_bar()
library(tidyr)
library(corrplot)
library(ggplot2)
cor_matrix<-cor(Boston)
cor_matrix %>% round(digits=2)
corrplot(cor_matrix, method="circle", type = "upper", cl.pos = "b", tl.pos = "d", tl.cex = 0.6)
gather(Boston) %>% ggplot(aes(value)) + facet_wrap("key", scales = "free") + geom_bar()
boston_scaled <- scale(Boston)
summary(boston_scaled)
class(boston_scaled)
boston_scaled <- as.data.frame(boston_scaled)
bins <- quantile(boston_scaled$crim)
crime <- cut(boston_scaled$crim, breaks = bins, include.lowest = TRUE, labels = c("low", "med_low", "med_high", "high"))
boston_scaled <- dplyr::select(boston_scaled, -crim)
boston_scaled <- data.frame(boston_scaled, crime)
head(boston_scaled)
n <- nrow(boston_scaled)
ind <- sample(n, size = n*0.8)
train <- boston_scaled[ind,]
test <- boston_scaled[-ind,]
dim(test)
dim(train)
lda.fit <- lda(crime ~ ., data = train)
lda.fit
plot(lda.fit, dimen = 2, col = classes, pch = classes)
lda.fit <- lda(crime ~ ., data = train)
lda.fit
lda.arrows <- function(x, myscale = 1, arrow_heads = 0.1, color = "orange", tex = 0.75, choices = c(1,2)){
heads <- coef(x)
arrows(x0 = 0, y0 = 0,
x1 = myscale * heads[,choices[1]],
y1 = myscale * heads[,choices[2]], col=color, length = arrow_heads)
text(myscale * heads[,choices], labels = row.names(heads),
cex = tex, col=color, pos=3)
}
classes <- as.numeric(train$crime)
plot(lda.fit, dimen = 2, col = classes, pch = classes)
lda.arrows(lda.fit, myscale = 1)
plot(lda.fit, dimen = 2, col = classes, pch = classes)
lda.arrows(lda.fit, myscale = 1)
correct_classes<-test$crime
test<-dplyr::select(test, -crime)
lda.pred <- predict(lda.fit, newdata = test)
table(correct = correct_classes, predicted = lda.pred$class)
table(correct = correct_classes, predicted = lda.pred$class)
table(correct = correct_classes, predicted = lda.pred$class) %>% prop.table() %>% addmargins()
#reloading
data(Boston)
#scale dataset and make data frame
boston_scaled1<-as.data.frame(scale(Boston))
dist_eu <-dist(boston_scaled1)
summary(dist_eu)
km <- kmeans(boston_scaled1, centers = 4)
pairs(Boston[1:6])
pairs(Boston)
set.seed(123)
k_max<- 10
#set the max number of clusters to be ten
k_max<- 10
#calculate total WCSS
twcss <- sapply(1:k_max, function(k){kmeans(Boston, k)$tot.withinss})
#calculate total WCSS
twcss <- sapply(1:k_max, function(k){kmeans(Boston, k)$tot.withinss})
#visualizing WCSS
qplot(x = 1:k_max, y = twcss, geom = 'line')
km <- kmeans(boston_scaled1, centers = 4)
km <- kmeans(boston_scaled1, centers = 2)
#visualize Kmeans
pairs(boston_scaled1, col = km$cluster)
pair(boston_scaled1[3,7:10, 13], col = km$cluster)
pairs(boston_scaled1[3,7:10, 13], col = km$cluster)
pairs(boston_scaled1[6:10], col = km$cluster)
# loading the cvs tables "Human development" and "Gender inequality" into R.
hd <- read.csv("http://s3.amazonaws.com/assets.datacamp.com/production/course_2218/datasets/human_development.csv", stringsAsFactors = F)
gii <- read.csv("http://s3.amazonaws.com/assets.datacamp.com/production/course_2218/datasets/gender_inequality.csv", stringsAsFactors = F, na.strings = "..")
# Exploring the structures and dimensions.
dim(hd)
str(hd)
colnames(hd)
dim(gii)
str(hd)
str(gii)
summary(hd)
summary(gii)
# Renaming the variables
colnames(hd)
colnames(hd)
colnames(hd)[1]<-"HDI.rank"
colnames(hd)[2]<-"country"
colnames(hd)[3]<-"HDI"
colnames(hd)[4]<-"lifeexp"
colnames(hd)[5]<-"exp.edu"
colnames(hd)[6]<-"mean.edu"
colnames(hd)[7]<-"GNI.cap"
colnames(hd)[8]<-"GNI.rank-HDI.rank"
colnames(hd)
colnames(gii)
colnames(gii)[1]<-"GII.rank"
colnames(gii)[2]<-"country"
colnames(gii)[3]<-"GII"
colnames(gii)[4]<-"matermor"
colnames(gii)[5]<-"adobr"
colnames(gii)[6]<-"reppar"
colnames(gii)[7]<-"fsecedu"
colnames(gii)[8]<-"msecedu"
colnames(gii)[9]<-"flabfor"
colnames(gii)[10]<-"mlabfor"
colnames(gii)
colnames(gii)[7]<-"edu2F"
colnames(gii)[8]<-"edu2M"
colnames(gii)
colnames(gii)[9]<-"labF"
colnames(gii)[10]<-"labM"
colnames(gii)
#Mutating the "Gender inequality" data in order to create two new variables.
gii <- mutate(gii, ratio.edu2 = gii$edu2F/gii$edu2M)
#Mutating the "Gender inequality" data in order to create two new variables.
#First accessing the tidyverse packages dplyr and ggplot2
library(dplyr)
gii <- mutate(gii, ratio.edu2 = gii$edu2F/gii$edu2M)
gii <- mutate(gii, ratio.lab = gii$labF/gii$labM)
colnames(gii)
summary(gii$ration.edu2)
summary(gii$ration.labforce)
summary(gii$ratio.edu2)
summary(gii$ratio.lab)
#Joining the two datasets using the variable country as the identifier.
human <- inner_join(hd, gii, by = "country")
dim(human)
setwd("/Users/eva-mariaroth/Documents/GitHub/IODS-project")
write.table(human, file = "human.csv", sep = ",", col.names = TRUE)
summary(Boston)
boston_scaled2 <-scale(Boston)
summary(boston_scaled2)
km2 <- kmeans(boston_scaled2, center = 3)
boston_scaled2 <- as.data.frame(boston_scaled2)
lda.fat <- lda(km2$cluster~., data = boston_scaled2)
library(MASS)
data("Boston")
library(tidyr)
library(corrplot)
library(ggplot2)
lda.fat <- lda(km2$cluster~., data = boston_scaled2)
lda.fit2 <- lda(km2$cluster~., data = boston_scaled2)
lda.arrows <- function(x, myscale = 1, arrow_heads = 0.1, color = "red", tex = 0.75, choices = c(1,2)){
heads <- coef(x)
arrows(x0 = 0, y0 = 0,
x1 = myscale * heads[,choices[1]],
y1 = myscale * heads[,choices[2]], col=color, length = arrow_heads)
text(myscale * heads[,choices], labels = row.names(heads),
cex = tex, col=color, pos=3)
}
# setting target classes as numeric
classes <- as.numeric(km2$cluster)
plot(lda.fit2, dimen = 2, col=classes, pch= classes)
lda.arrows(lda.fit, myscale = 1)
model_predictors <- dplyr::select(train, -crime)
# check the dimensions
dim(model_predictors)
dim(lda.fit$scaling)
# matrix multiplication
matrix_product <- as.matrix(model_predictors) %*% lda.fit$scaling
matrix_product <- as.data.frame(matrix_product)
install.packages(plotly)
install.packages("plotly")
library(plotly)
plot_ly(x = matrix_product$LD1, y = matrix_product$LD2, z = matrix_product$LD3, type= 'scatter3d', mode='markers'
plot_ly(x = matrix_product$LD1, y = matrix_product$LD2, z = matrix_product$LD3, type= 'scatter3d', mode='markers')
plot_ly(x = matrix_product$LD1, y = matrix_product$LD2, z = matrix_product$LD3, type= 'scatter3d', mode='markers')
plot_ly(x = matrix_product$LD1, y = matrix_product$LD2, z = matrix_product$LD3, type= 'scatter3d', mode='markers', color = train$crime)
plot_ly(x = matrix_product$LD1, y = matrix_product$LD2, z = matrix_product$LD3, type= 'scatter3d', mode='markers', color = km$cluster)
colnames(km)
plot_ly(x = matrix_product$LD1, y = matrix_product$LD2, z = matrix_product$LD3, type= 'scatter3d', mode='markers', color = km2$cluster)
km <- kmeans(boston_scaled1, centers = 2)
km <- kmeans(boston_scaled1, centers = 4)
#reloading
data(Boston)
#scale dataset and make data frame
boston_scaled1<-as.data.frame(scale(Boston))
dist_eu <-dist(boston_scaled1)
summary(dist_eu)
km <- kmeans(boston_scaled1, centers = 4)
set.seed(123)
#set the max number of clusters to be ten
k_max<- 10
#calculate total WCSS
twcss <- sapply(1:k_max, function(k){kmeans(Boston, k)$tot.withinss})
#visualizing WCSS
qplot(x = 1:k_max, y = twcss, geom = 'line')
km <- kmeans(boston_scaled1, centers = 2)
#visualize Kmeans
pairs(boston_scaled1, col = km$cluster)
pairs(boston_scaled1[6:10], col = km$cluster)
plot_ly(x = matrix_product$LD1, y = matrix_product$LD2, z = matrix_product$LD3, type= 'scatter3d', mode='markers', color = km$cluster)
plot_ly(x = matrix_product$LD1, y = matrix_product$LD2, z = matrix_product$LD3, type= 'scatter3d', mode='markers', color = train$cl)
plot_ly(x = matrix_product$LD1, y = matrix_product$LD2, z = matrix_product$LD3, type= 'scatter3d', mode='markers', color = train$crime)
